#!/usr/bin/bash

map u up
map e down
map i open
map n updir
map <esc> unselect

set findlen 2
# set hidden
set incsearch
set incfilter
set scrolloff 4
set tabstop 2
set smartcase
# set dircounts
# set info size
# set sortby natural
set ratios '1:3'
set timefmt '2006-01-02 15:04:05 -0700'
set previewer ~/.config/lf/preview

map y
map c copy
map CC clear
cmd yank-path &printf '%s' "$fx" | pbcopy
map yp yank-path

cmd yank-base $basename -a -- $fx | head -c-1 | pbcopy
map yb yank-base

map gf $lf -remote "send $id select $(fzf)"
cmd fzf_search ${{
    res="$( \
        RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case "
        FZF_DEFAULT_COMMAND="$RG_PREFIX ''" \
            fzf --ansi \
                --disabled \
                --bind "change:reload:sleep 0.1; $RG_PREFIX {q} || true" \
                \   # --multi \  # TODO doesn't work currently
                --delimiter : \
                --preview 'bat --color=always {1} --highlight-line {2}' \
                --preview-window 'up,60%,border-bottom,+{2}+3/3,~3' \
                --bind 'ctrl-e:become(subl {1}:{2})' \
            | cut -d':' -f1  # TODO this only takes the first match
    )"
    [ ! -z "$res" ] && lf -remote "send $id toggle \"$res\""
}}
map gs :fzf_search

set promptfmt "
\033[33;1m%h\033[0m    \033[0m\033[1m%d\033[0m
"

map sg &tmux split-window -h lf
map sv &tmux split-window -v lf

# set sortby time
# set reverse

cmd doc ${{
    lf -doc | bat -l md
}}

cmd select-tagged &{{
    files=$(cat  ~/.local/share/lf/tags | tr -d ':*' | tr '\n' ' ')
    lf -remote "send toggle $files"
}}
map T select-tagged

cmd trash-restore ${{
    trash-list |
        sort -r |
        grep " $PWD/" |
        fzf --multi |
        cut -d' ' -f3- |
        while IFS= read -r line; do
            [ -n $line ] && yes 0 | trash-restore -- $line > /dev/null
        done
}}

map D trash-restore

map l filter

# TODO: this should be done in python
# cmd cut-add %{{
#     files=$(cat ~/.local/share/lf/files | tail -n +2)
#     echo "$fx" >> ~/.local/share/lf/files

#     newline=$'\n'
#     # lf -remote "save${newline}move${newline}${new_files}${newline}"
#     lf -remote "send $id unselect"
#     lf -remote "send sync"
# }}
# map Y cut-add

# cmd cut-remove %{{
#     files=$(lf -remote load)
#     operation=$(echo "$files" | head -n1)

#     if [ "$operation" != "move" ]; then
#         lf -remote "send $id echoerr no files in cut list."
#         exit 1
#     fi

#     files=$(echo "$files" | tail -n +2)
#     newline=$'\n'

#     # change to $fx to remove current file when no toggled
#     # files exist.
#     if [ -n "$files" ]; then
#         # here we want all files in $files that aren't in $fs, making sure
#         # that none of the entries in $fs are included, even when they aren't
#         # in $files. To do this we concatenate $files and $fs (twice), printing
#         # only the uniqe lines.
#         new_files=$(echo "$files$newline$fs$newline$fs" | sort | uniq -u)
#     else
#         new_files=$files
#     fi
#     new_files=$(echo "$new_files" | sed --quiet -e '/^$/d' -e 'p')

#     lf -remote "save${newline}move${newline}${new_files}${newline}"
#     lf -remote "send $id unselect${newline}send $id sync"
# }}

map R $printf '%s\n' "`ls`" | renamer

# y (select for copy) and P to paste soft-link
# d (select for cut) and P to paste hard-link
cmd link %{{
    set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift
    if [ "$#" -lt 1 ]; then
        lf -remote "send $id echo no files to link"
        exit 0
    fi
    case "$mode" in
        # symbolically copy mode is indicating a soft link
        copy) gln -sr -t . -- "$@";;
        # while a move mode is indicating a hard link
        move) gln -t . -- "$@";;
    esac
    rm ~/.local/share/lf/files
    lf -remote "send clear"
}}
map P :link

cmd trash %trash-put $fx
map d :trash
map x :cut

cmd zle-cd %printf 'cd %q && zle reset-prompt\n' "$PWD" >&$ZLE_FIFO

cmd jump ${{
    result="$(zoxide query -i)"
    lf -remote "send $id cd $result"
}}

map j jump

cmd subl ${{
    subl .
}}

map S subl

# # zsh insertion/cd widget
# cmd zle-insert-relative %{{
#     for f in $fx; do
#         printf 'LBUFFER+="${LBUFFER:+ }${(q)$(realpath %q --relative-to=$PWD)}"\n' "$f" >&$ZLE_FIFO
#     done
# }}

# cmd zle-insert-absolute %{{
#     for f in $fx; do
#         printf 'LBUFFER+="${LBUFFER:+ }%q"\n' "$f" >&$ZLE_FIFO
#     done
# }}

# cmd zle-init :{{
#     map . zle-cd
#     map a zle-insert-relative
#     map A zle-insert-absolute
# }}

# &[[ -n "$ZLE_FIFO" ]] && lf -remote "send $id zle-init"


## DEFAULT ##

# interpreter for shell commands
set shell sh

# set '-eu' options for shell commands
# These options are used to have safer shell commands. Option '-e' is used to
# exit on error and option '-u' is used to give error for unset variables.
# Option '-f' disables pathname expansion which can be useful when $f, $fs, and
# $fx variables contain names with '*' or '?' characters. However, this option
# is used selectively within individual commands as it can be limiting at
# times.
set shellopts '-eu'

# set internal field separator (IFS) to "\n" for shell commands
# This is useful to automatically split file names in $fs and $fx properly
# since default file separator used in these variables (i.e. '$' option)
# is newline. You need to consider the values of these options and create your
# commands accordingly.
set ifs "\n"

# leave some space at the top and the bottom of the screen
# set scrolloff 10

# Use the `dim` attribute instead of underline for the cursor in the preview pane
# set cursorpreviewfmt "\033[7;2m"

# use enter for shell commands
map <enter> shell

# execute current file (must be executable)
# map x $$f
map X !$f

# dedicated keys for file opener actions
# map o &mimeopen $f
# map O $mimeopen --ask $f

# define a custom 'open' command
# This command is called when current file is not a directory. You may want to
# use either file extensions and/or mime types here. Below uses an editor for
# text files and a file opener for the rest.
# cmd open &{{
#     case $(file --mime-type -Lb $f) in text/*);
#     lf -remote "send $id \$$EDITOR \$fx";;
#         *) for f in $fx; do $OPENER $f > /dev/null 2> /dev/null & done;;
#     esac
# }}

cmd open &{{
    mime=`file --mime-type -b $f`
    if echo $mime | grep 'text' -q ; then
      subl $fx
    else
      open $fx
    fi
}}

cmd quicklook &{{
    mime=`file --mime-type -b $f`
    if echo $mime | grep 'text' -q ; then
      subl -b --command "preview_file {\"file\": \"$fx\"}"
    elif echo $mime | grep 'image' -q ; then
      open -a "XeeÂ³" -g $fx
    else
      qlmanage -p $fx &> /dev/null
    fi
}}

map o quicklook

cmd on-quit &{{
    pwd > /tmp/lf_pwd
    echo $fs > /tmp/lf_fs
    echo $fx > /tmp/lf_fx
}}


cmd insert-pwd :{{
    & pwd > /tmp/lf_insert
    quit
}}

cmd insert-selection :{{
    & echo $fx > /tmp/lf_insert
    quit
}}

cmd inserter :{{
    map . insert-pwd
    map <enter> insert-selection
}}

set previewer ~/.config/lf/pv.sh

${{
    w=$(tput cols)
    if [ $w -le 80 ]; then
        lf -remote "send $id set ratios 1:2"
    elif [ $w -le 160 ]; then
        lf -remote "send $id set ratios 2:5"
    else
        lf -remote "send $id set ratios 1:5"
    fi
}}

set mouse on

cmd mkdir %{{
    IFS=" "
    mkdir -p -- "$*"
    lf -remote "send $id select \"$*\""
}}
map m push :mkdir<space>

cmd newfold ${{
    mkdir -p -- "$*"
    mv -- $fx "$*"
    lf -remote "send $id select \"$*\""
}}
map M push :newfold<space>


# map i $~/.config/lf/pv.sh $f | less -R

# define a custom 'rename' command without prompt for overwrite
# cmd rename %[ -e $1 ] && printf "file exists" || mv $f $1
# map r push :rename<space>

# make sure trash folder exists
# %mkdir -p ~/.trash

# move current file or selected files to trash folder
# (also see 'man mv' for backup/overwrite options)

# define a custom 'delete' command
# cmd delete ${{
#     set -f
#     printf "$fx\n"
#     printf "delete?[y/n]"
#     read ans
#     [ "$ans" = "y" ] && rm -rf $fx
# }}

# use '<delete>' key for either 'trash' or 'delete' command
# map <delete> trash
# map <delete> delete

# extract the current file with the right command
# (xkcd link: https://xkcd.com/1168/)
cmd extract ${{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;
        *.tar.gz|*.tgz) tar xzvf $f;;
        *.tar.xz|*.txz) tar xJvf $f;;
        *.zip) unzip $f;;
        *.rar) unrar x $f;;
        *.7z) 7z x $f;;
    esac
}}

# compress current file or selected files with tar and gunzip
cmd tar ${{
    set -f
    mkdir $1
    cp -r $fx $1
    tar czf $1.tar.gz $1
    rm -rf $1
}}

# compress current file or selected files with zip
cmd zip ${{
    set -f
    mkdir $1
    cp -r $fx $1
    zip -r $1.zip $1
    rm -rf $1
}}
